<!DOCTYPE html>

<html>
    <head>
        <title>WebGL Pipelines</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel="shortcut icon" href="../../../images/png/WebGL-Logo.png" type="image/png" />
        
        <link rel="stylesheet" href="../../../css/style.css">
        <link rel="stylesheet" href="../../../css/document.css">
        
        <style type="text/css">
            img, object {
                border: 1px solid #666;
                box-shadow: 3px 3px 3px #666;
                display: block;
                margin: 0 auto;
            }
        </style>
        
        <script src="../../../js/htmlDocUtils.js"></script>
    </head>
    <body>
        <article>
            <header>
                <h1>WebGL Pipelines</h1>
                <p class='authorinfo'>Sarkuya, <time>2019-05-19</time></p>
            </header>
            
            <section class="chapter">
                <h1>How WebGL Draw</h1>
                <p>In order to draw something in the canvas, we need to issue certain drawing methods. WebGL has only 3 methods dealing with drawing:</p>
                <ul>
                    <li>clear</li>
                    <li>drawArrays</li>
                    <li>drawElements</li>
                </ul>
                <p>We have encountered the <span class="function-name">clear</span> method before, and in the following section we'll talk about <span class="function-name">drawElements</span>. In this section, we discuss <span class="function-name">drawArrays</span> first.</p>
                <p>Suppose we shall draw a triangle. First, we need to provide the vertices. Second, issue the drawing method. The code is below:</p>
                <pre class="highlight">
var vertices = [
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
];

gl.drawArrays(gl.TRIANGLES, 0, 3);  // intent: use the array data in vertices to draw a triangle
</pre>
                <p>The synopsis of the <span class="function-name">drawArrays</span> is as followed.</p>
                <pre>void drawArrays(GLenum mode, GLint first, GLsizei count)</pre>
                <p><span class="parameter">mode</span> specifies the kind of primitives. Accepted constants are gl.<span class="constant">POINTS</span>, gl.<span class="constant">LINE_STRIP</span>, gl.<span class="constant">LINE_LOOP</span>, gl.<span class="constant">LINES</span>, gl.<span class="constant">TRIANGLE_STRIP</span>, gl.<span class="constant">LINE_FAN</span>, and  gl.<span class="constant">TRIANGLES</span>, where <span class="variable-name">gl</span> is an instance of the <span class="class-name">WebGLRenderingContext</span>.</p>
                <p><span class="parameter">first</span> specifies the starting index of the array.</p>
                <p><span class="parameter">count</span> specifies the number of vertices to be rendered.</p>
                <p>There are 3 points in vertices array data. Each point has a pair of array elements. From the first point, which starting index is 0, fetches altogether 3 vertices to draw triangles. In this situation, 3 vertices would compose only 1 triangle.</p>
                <p>You can see from the code that there are no connections between the <span class="function-name">drawArrays</span> and the vertices. So how WebGL know where to get the array data from?</p>
                <p>WebGL will rather get the array data from a buffer, than directly from the vertices we are providing. The buffer is resident in GPU, and the speed of data transmission from it is much faster than from the vertices, which is resident in JavaScript client side.</p>
                <p>So, we need to do the following jobs:</p>
                <ol>
                    <li>create a buffer (in GPU)</li>
                    <li>copy the data from the vertices to the buffer</li>
                    <li>tell WebGL to fetch array data from the buffer</li>
                </ol>
                <pre class="highlight">
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var vertices = [
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
];

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
</pre>
                <p>Notice the first argument of the <span class="function-name">bufferData</span> is gl.<span class="constant">ARRAY_BUFFER</span>. 
This is the specific buffer binding target where the WebGL would fetch the array data. 
So after we created a buffer, we bind the buffer to the target gl.ARRAY_BUFFER. 
<span class="function-name">bufferData</span> connects the buffer with gl.ARRAY_BUFFER via putting the latter as its first argument.
So the array data from the vertices would be copied to the GPU's buffer.</p>
                <p>The second argument of the <span class="function-name">bufferData</span> is of type TypedArray.</p>
                <table>
                    <thead>
                        <tr><th>Name</th><th>Type</th><th>Element Size (in bytes)</th><th>Equivalent C Type</th><th>Range</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>Int8Array</td><td>Integer</td><td>1</td><td>singed char</td><td>[-128, 127]</td></tr>
                        <tr><td>Uint8Array</td><td>Integer</td><td>1</td><td>unsinged char</td><td>[0, 255]</td></tr>
                        <tr><td>Uint8ClampedArray</td><td>Integer</td><td>1</td><td>unsinged char</td><td>[0, 255]</td></tr>
                        
                        <tr><td>Int16Array</td><td>Integer</td><td>2</td><td>short</td><td>[-32768, 32767]</td></tr>
                        <tr><td>Uint16Array</td><td>Integer</td><td>2</td><td>unsigned short</td><td>[0, 65535]</td></tr>
                        
                        <tr><td>Int32Array</td><td>Integer</td><td>4</td><td>int</td><td>[-2147483648, 2147483647]</td></tr>
                        <tr><td>Uint32Array</td><td>Integer</td><td>4</td><td>unsigned int</td><td>[0, 4294967295]</td></tr>
                        
                        <tr><td>Float32Array</td><td>Floating</td><td>4</td><td>float</td><td>[1.17549e-38, 3.40282e+38]</td></tr>
                        <tr><td>Float64Array</td><td>Floating</td><td>8</td><td>double</td><td>[2.22507e-308, 1.79769e+308]</td></tr>
                    </tbody>
                </table>
                
                <p>Then when we issue the drawing method, WebGL konws it should get the vertex data from the buffer to render the image.</p>

                <object type="image/svg+xml" data="images/svg/pipelines.svg"></object>
                
                <p>We need to deal with the following objects:</p>
                <ul>
                    <li>WebGLRenderingContext</li>
                    <li>shaders</li>
                    <li>program</li>
                    <li>buffer</li>
                    <li>vertices</li>
                    <li>drawing functions</li>
                </ul>
            </section>
            
            <section class="chapter">
                <h1>Coming the Shaders</h1>
                <p>When we issue the drawing method, again, WebGL would never fetch the data directly from the buffer. 
                    Rather, it would ask the <em>shaders</em> to provide the corresponding informations. Shaders are executed on the <em>GPU</em>, so their speed are extremely fast.</p>
                <p>There are several shaders in WebGL. Among of them, vertex shader and fragment shader are two shaders which are mandatory in each WebGL application, while other shaders are optional.</p>
                <p>Put in simplified, vertex shader deals with the positions of vertices, while fragment deals with the colors of vertices.</p>
                <p>The following driagram illustrates how WebGL fetch the data from the vertex shader and fragment shader to render the final image.</p>
                <object type="image/svg+xml" data="images/svg/shaders.svg"></object>
                <p>After we issued the drawing method:</p>
                <pre class="highlight">
gl.drawArrays(gl.TRIANGLES, 0, 3);
</pre>
                <p>We tells WebGL to fetch 3 vertex components, starting from index 0, to construct a triangle. 
Each component contains 2 array elments, relating to the X axis and Y axis coordinate.</p>
                <p>In deciding the first vertex, the first two array elements, [0.0, 0.5] will be passed to the vertex shader, and be assigned to the special variable <span class="variable-name">gl_Position</span>. To achive this, we can code like this using <em>GLSL</em>(OpenGL Shading Language):</p>
                <pre class="highlight">
attribute vec4 vPosition;

void main()
{
    gl_Position = vPosition;
}
</pre>
                <p>Here, "attribute" is a storage qualifier. The attribute <span class="variable-name">vPosition</span> is a variable in vertex shader that can accept the data from the buffers on a per-vertex basis. The attribute qualifier exists in vertex shader only, not other shaders. We can regard it as a tunnel connecting with the buffers and shaders. 
WebGL would transfer data [0.0, 0.5] from the buffer to <span class="variable-name">vPosition</span>. Then, in the <span class="function-name">main</span> function, its value is assigned to <span class="variable-name">gl_Position</span>.</p>
                <p>Putting vertex data in <span class="variable-name">vPosition</span> is the final step in this stage to decide each vertex's position from the view of a programmer. Many other left dirty works would be handled by WebGL in pipelines from now on, but not for programmer.</p>
                <p>Then, this data would be passed on to the the Fragment Shader in WebGL's rendering pipelines. As the first WebGL program based on shaders, we can simplify the issue by assign all vertices with just a yellow color. Code like this:</p>
                <pre class="highlight">
precision mediump float;

void main()
{
    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
}
</pre>
                <p>We use 'float' to describe the precision of the data. 
Just like <span class="variable-name">gl_Position</span>, <span class="variable-name">gl_FragColor</span> is a special variable that deal with vertex color. 
We hard-coded the yellow color value and assigned it to <span class="variable-name">gl_FragColor</span>, which means no matter how many vertices we have, they all have a same color.</p>
                <p>Now the Fragment Shader has the information of a vertex's position and its color, which is enough to plot a pixel in screen. So the data is moved on to the frame buffer to be rendered. This first vertex is thus rendered on screen. And this finishes the first cycle of invocation of <span class="function-name">glDrawArrays(gl.TRIANGLES, 0, 3)</span>.</p>
                <p>The last parameter in <span class="function-name">glDrawArrays(gl.TRIANGLES, 0, 3)</span> tells WebGL that there would be 2 vertices left. Again, WebGL asks the Vertex Shader to provide the information of the second vertex. Then, the 2th and the 3rd array elements, [-0.5, -0.5] will passed on to <span class="variable-name">gl_Position</span> in Vertex Shader. The remaiming procedures are the same with above - data would be moved on to the Fragment Shader and then to the Frame Buffer to plot the second vertex on screen.</p>
                <p>As for the 3rd cycle, [0.5, -0.5] would be extracted from the buffer to the shaders and then the Frame Buffer. Thus, a t yellow triangle is rendered.</p>
                <p>You can see that Shading Language is powerful - there is only 1 <span class="variable-name">gl_Position</span> for all vertice's positions and 1 <span class="variable-name">gl_FragColor</span> all for vertices' colors. We write in less codes and WebGL do much more works to get all vertice's information. It would be true that Shading Language shown above is much easier than any other programming language, such as C, Java, even JavaScript. Despite of this, Shading Language is nevertheless a programming language, and just like any other one, it needs to be compiled and linked before being used.</p>
            </section>
            
            <section class="chapter">
                <h1>Compiling and Linking of Shaders</h1>
                <p>We now know what shaders are, how they function, and how to write codes for shaders, then one issue is left here: get the shaders compiled and linked. The following dragram shows the procedures how to do this.</p>
                <img src="images/svg/compile-shaders.svg" alt="Preparing Program" />
                <p>Although it might look rather complicated, the big picture is simple: create 2 shaders, attatch them to a program, link the program, and use the program.</p>
                
                <section>
                    <h1>Creating Shaders</h1>
                    <p>The procedures of creating the vertex shader and fragment shader are the same, so we could put the codes of creating shaders in a function.</p>
                    <p>Before we do it, we should decide where to put the shader sources first. </p>
                    <p>Shader's sources are plain texts. So we can write them in a text file and load the text file using the AJAX. However, for a simple WebGL application, there's a good place for holding the shaders' sources - <span class="htmltag">script</span> element in a HTML file.</p>
                    <p>For JavaScript to be executed by the web browser, we usually specify its <span class="attribute-name">type</span> attribute.</p>
                    <pre class="highlight">
&lt;script type="text/javascript"&gt;
    ...
&lt;/script&gt;
</pre>
                    <p><span class="attribute-name">type</span> specifies the MIME type. It contains the information of media type and its sub-type. For the code above, the media type is text, and its sub-type is javascript.</p>
                    <p>If we don't specify the <span class="attribute-name">type</span>, it is assumed to be JavaScript by default. And if we specify another type rather than 'javascript' for the <span class="htmltag">script</span>, this script would not be treated as JavaScript and would not be executed by browsers.</p>
                    <p>Although it's not the standard, Khronos takes 'x-shader/x-vertex' for the vertex shader and 'x-shader/x-fragment' for the fragment shader.</p>
                    <p>So, let's add 2 scripts specific to WebGL under the <span class="htmltag">head</span> of <span class="htmltag">html</span>.</p>
                    <pre class="highlight">
&lt;html&gt;
    &lt;head&gt;
        ...

        &lt;script id="vshader" type="x-shader/x-vertex"&gt;
            attribute vec4 vPosition;

            void main()
            {
                gl_Position = vPosition;
            }
        &lt;/script&gt;

        &lt;script id="fshader" type="x-shader/x-fragment"&gt;
            precision mediump float;

            void main()
            {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
            }
        &lt;/script&gt;
        ...
    &lt;/head&gt;

    ...
&lt;/html&gt;
</pre>
                    <p>Then, we use a function to load both of the shaders.</p>
                    <pre class="highlight">
function loadShader(ctx, shaderId)
{
    var shaderScript = document.getElementById(shaderId);
    
    if (!shaderScript) {
        console.log("Error: shader script '" + shaderId + "' not found");
        return null;
    }

    var shaderType;
    
    if (shaderScript.type === "x-shader/x-vertex")
        shaderType = ctx.VERTEX_SHADER;
    else if (shaderScript.type === "x-shader/x-fragment")
        shaderType = ctx.FRAGMENT_SHADER;
    else {
        console.log("Error: shader script '" + shaderId + "' of undefined type '" + shaderScript.type + "'");
        return null;
    }

    var shader = ctx.createShader(shaderType);

    ctx.shaderSource(shader, shaderScript.text);
    ctx.compileShader(shader);

    var compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
    if (!compiled) {
        var error = ctx.getShaderInfoLog(shader);
        console.log("Error compiling shader '" + shaderId + "':" + error);
        ctx.deleteShader(shader);
        return null;
    }

    return shader;
}
</pre>
                </section>
                
                <section>
                    <h1>Getting the Program Ready</h1>
                    <p>We put the codes of preparing a program into a function and invoke it.</p>
                    <pre class="highlight">
function prepareProgram(vshader, fshader) {
    var vertexShader = loadShader(gl, vshader);
    var fragmentShader = loadShader(gl, fshader);

    var program = gl.createProgram();

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);

    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
        var error = gl.getProgramInfoLog(program);
        console.log("Error in program linking: " + error);

        gl.deleteProgram(program);
        gl.deleteProgram(fragmentShader);
        gl.deleteProgram(vertexShader);

        return null;
    }

    gl.useProgram(program);

    return program;
}

gl.program = prepareProgram("vshader", "fshader");
</pre>
                </section>
            </section>
            
            <section class="chapter">
                <h1>Telling WebGL How to Fetch Data</h1>
                <p></p>
                
                <section>
                    <h1>What are Shader's Attributes</h1>
                    <p>Buffers are memory areas managed by WebGL system, which are located in the ordinary memory. If we can transfer the data in buffers to GPU's memories, and process graphics-relating tasks such as lighting computing in GPU to leverage the full capabilities of GPU, that would be a better solution in performance. WebGL adopts such a solution in its rendering pipelines.</p>
                    <p>In shading language, attribute variables are such ones that can accept and store the data from outside the GPU. Each attribute variable points to a small block of memory spaces allocated in GPU. The diagram below illustrates this.</p>
                    <img src="images/svg/shader-attribute-1.svg" alt="Shader Attributes" />
                    <p>We can see that, each attribute variable has an index, 4 components, a name, and a flag that indicates whether it is enabled as an array.</p>
                    <p>The numbers of vertex attributes are limited in each implementation. We can query the max vertex attributes numbers by passing the gl.<span class="constant">MAX_VERTEX_ATTRIBS</span> constant to the <span class="function-name">getParameter</span> method.</p>
                    <pre class="highlight">
var vertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);    // 16 in Safari V11.1
</pre>
                    <p>In all shaders, only vertex shader has attribute variables.</p>
                    
                </section>
                
                <section>
                    <h1>Index and Name</h1>
                    <p></p>
                    <p>We coded for the vertex shader as followed before:</p>
                    <pre class="highlight">
&lt;script id="vshader" type="x-shader/x-vertex"&gt;
    attribute vec4 vPosition;

    void main()
    {
        gl_Position = vPosition;
    }
&lt;/script&gt;
</pre>
                    <p>Here, the keyword "<em>attribute</em>" is called <em>storage qualifier</em>. Its type is vec4, and its name is "vPosition". With this declaration, the WebGL' states turns into:</p>
                    <img src="images/svg/shader-attribute-2.svg" alt="Shader Attributes" />
                    <p>It means that the first attribute space, whose index is 0, will be reserved for 'vPosition' variable.</p>
                    <p>From the view of the code, we know there is a attribute named 'vPosition', while we don't know the exact index of it. By invoking the gl.getAttribLocation method, we can get its index.</p>
                    <pre class="highlight">
var index = gl.getAttribLocation(gl.program, "vPosition");
</pre>
                </section>
                
                <section>
                    <h1>Four Componets in an Attribute</h1>
                    <p>Normally, we declare attributes to store the data of position, color, normal, texture cocordinte and matrix. All of these data have max 4 compoments. To reflect with this, each attribute has 4 components. For position, color, normal and texture coordinate, each component has a floating-point value. As for the matrix, we have kinds of mat4, mat3, and mat2. A mat4 would use up 4 attribute variable location, a mat3 would use up 3 attrbute variable location, and a mat2 would use up 2 attribute variable location.</p>
                </section>
                
                <section>
                    <h1>How to Set an Attribute's Value</h1>
                    <p>There are 2 ways to set an attribute's value. </p>
                    <p>The first way is to set directly by invoking the gl's method <span class="function-name">vertexAttrib</span>, which we'll deal with later.</p>
                    <p>The second way is driven by gl's method <span class="function-name">drawArrays</span>, or <span class="function-name">drawElments</span>. In this way, the attribute's value are not set directly, but rather, they are set by accepting the data transfered from buffers. However, to make this happened, we would have to do 3 jobs first:</p>
                    <ol>
                        <li>make an attribute active</li>
                        <li>enable the attribute as an array</li>
                        <li>tell WebGL the rules to fetch the data</li>
                    </ol>
                    
                    <section>
                        <h1>Make an Attribute Active</h1>
                        <p>An attribute variable is considered active if it is determined during the link operation that it may be accessed during program execution.</p>
                        <pre class="highlight">
attribute vec4 vPosition;
attribute vec4 vTest;

void main()
{
    gl_Position = vPosition;
}
</pre>
                        <p>We declared 2 attributes. Only <span class="variable-name">vPosition</span> is being used to assign its value to <span class="variable-name">gl_Position</span>, which can be determined during the link operation. In short, it was consumed. So, only <span class="variable-name">vPosition</span> is active and <span class="variable-name">vTest</span> is not.</p>
                    </section>
                    
                    <section>
                        <h1>Enable the Attribute as an Array</h1>
                        <p>Since <span class="variable-name">vPosition</span> is about to be accessed to assign values to <span class="variable-name">gl_Position</span>, it should have its value set before that. As we said before that being an attribute, <span class="variable-name">vPosition</span> has 4 floating components. We should turn these 4 components into an array if it is about to accept data from a buffer which is in a form of array for the efficiency. And that's why <span class="function-name">glDrawArrays</span> is so named: it would fetch data from arrays to render images.</p>
                        <p>By default, all generic vertex attribute arrays are disabled. So, we should enable the generic vertex attribute array like this:</p>
                        <pre class="highlight">
var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);
</pre>
                        <img src="images/svg/shader-attribute-3.svg" alt="Shader Attributes" />
                        
                        <p><span class="function-name">enableVertexAttribArray</span> method enables the vertex attribute at index as an array. Only when the attribute is enabled, would the values in the generic vertex attribute array be accesed when rendering.</p>
                        <p><span class="function-name">drawArrays</span> would require a specific vertex attrubte enabled just before invoking it. So the invokation of <span class="function-name">enableVertexAttribArray</span> can be defered anywhere just before the invokation of <span class="function-name">drawArrays</span>.</p>
                        <p>If we try to enable an attribute which is not active , error would occur.</p>
                    </section>
                    
                    <section>
                        <h1>Tell WebGL the Rules to Fetch the Data</h1>
                        <p>At this time, we have finished the following relating statements:</p>
                        <pre class="highlight">
// buffer created and bound before
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);
</pre>
                        <p>The buffer bound to gl.ARRARY_BUFFER target is the current bounding buffer that would transfer its data to vertex shader. However, since we can enable more than one attribute as array in a certain time, we have no information which attribute would accept the data from the buffer.</p>
                        <p>Second, the data from the buffer might contain more than merely the vertices's position data, like this:</p>
                        <pre class="highlight">
var vertices = [
   //positions     colors        
     0.0,  0.5,    1.0, 0.0, 0.0,
    -0.5, -0.5,    0.0, 1.0, 0.0,
     0.5, -0.5,    0.0, 0.0, 1.0
];
</pre>
                        <p>Since vertex shader cares about only the vertice's position, we should tell WebGL how to fetch the vertice's position out of such mixed array buffer.</p>
                        <p><span class="function-name">vertexAttribPointer</span> serves for this purpose as well, specified in its arguments.</p>
                        <p>Let's take the mixed vertices in example to illustrate the functionality of <span class="function-name">vertexAttribPointer</span> first, and then a vertex of pure positions, since the first is a better demo than the latter.</p>
                        <p>Put the previous relevant codes here again:</p>
                        <pre class="highlight">
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var vertices = [
   //positions     colors    
     0.0,  0.5,    1.0, 0.0, 0.0,
    -0.5, -0.5,    0.0, 1.0, 0.0,
     0.5, -0.5,    0.0, 0.0, 1.0
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);

gl.vertexAttribPointer(index, 2, gl.FLOAT, false, 0, 0);
</pre>
                        
                        
                        <p><span class="function-name">vertexAttribPointer</span> is a bridge that connects with 2 ends. As the codes above shows, one end is the buffer we created and bound to the gl.<span class="constant">ARRAY_BUFFER</span> before, and the other end is <span class="variable-name">vPosition</span>. So, by using <span class="function-name">vertexAttribPointer</span>, we tell WebGL where to fetch the data, and where to transfer.</p>
                        
                        <p>We can invoke <span class="function-name">getVertexAttrib</span> to query informations.</p>
                        
                        <section>
                            <h1>Buffer Data in Details</h1>
                            <p>For the codes:</p>
                            <pre class="highlight">
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var vertices = [
   //positions     colors    
     0.0,  0.5,    1.0, 0.0, 0.0,
    -0.5, -0.5,    0.0, 1.0, 0.0,
     0.5, -0.5,    0.0, 0.0, 1.0
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
</pre>
                            <p>The memory allocation for the buffer is as followed:</p>
                            <img src="images/svg/buffer-memory-allocation.svg" alt="Buffer Memory Allocation" />
                            <p>There are altogether 3 vertices in the buffer. Each vertex contains information of positions and colors. The elements for the positions are filled with green background color and the ones for the colors are filled with light blue.</p>
                            <p>Since we declare only one attribute -- 'aPosition' in the vertex shader, WebGL cares about only the positions information. So, how can we tell WebGL to extract the positions data from such an array? We do this by invoking <span class="function-name">vertexAttribPointer</span> method. It assigns the buffer object currently bound to ARRAY_BUFFER target to a specific vertex attribute and specify the rules on how to extract the relevant data.</p>
                            <p>The synopsis of the <span class="function-name">vertexAttribPointer</span>:</p>
                            <pre>void vertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset)</pre>
                            <p>We show the codes first and then explain.</p>
                            <pre>
var index = gl.getAttribLocation(gl.program, "vPosition");
gl.vertexAttribPointer(index, 2, gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT * 5, 0);
</pre>
                            <p>The first parameter <span class="parameter">index</span> connects with the buffer and the vertex attribute. With this connection, the data would be transfered from the buffer to the vertex attribute.</p>
                            <p>Since the data type of the buffer is Float32Array, we specify GLenum 'FLOAT' for the parameter <span class="parameter">type</span>. For other typed arrays and their relevant GLenum type, see below.</p>
                            <table>
                                <thead>
                                    <tr><th>TypedArray</th><th>GLenum</th></tr>
                                </thead>
                                <tbody>
                                    <tr><td>Int8Array</td><td>BYTE</td></tr>
                                    <tr><td>Uint8Array</td><td>UNSIGNED_BYTE</td></tr>
                                    <tr><td>Uint8ClampedArray</td><td>UNSIGNED_BYTE</td></tr>

                                    <tr><td>Int16Array</td><td>SHORT</td></tr>
                                    <tr><td>Uint16Array</td><td>UNSIGNED_SHORT</td></tr>

                                    <tr><td>Int32Array</td><td>INT</td></tr>
                                    <tr><td>Uint32Array</td><td>UNSIGNED_INT</td></tr>

                                    <tr><td>Float32Array</td><td>FLOAT</td></tr>
                                    <tr><td>Float64Array</td><td>FLOAT</td></tr>
                                </tbody>
                            </table>
                            <p>Parameter <span class="parameter">size</span>, <span class="parameter">stride</span> and <span class="parameter">offset</span> is illustrated in the following dragram.</p>
                            <img src="images/svg/vertexAttribPointer-diagram.svg" alt="vertexAttribPointer-diagram" />
                            <p><span class="parameter">offset</span> tells where to start to fetch data. Here, we specify '0' for it, telling WebGL that it should start from the element indexed with 0.</p>
                            <p><span class="parameter">size</span> tells how many elements to fetch once upon a time to feed the vertex attribute 'aPosition'. Since we use only 2 floats to represent a vertex position, we specify '2' for the <span class="parameter">size</span>. Then only 2 elements in the array would be fetched at a time. So, [0.0, 0.5] would be fetched at the first time.</p>
                            <p>The next 3 elements are about color information, and should not be fetched to 'aPosition'. They should be skipped each time. As the diagram shown above, we need to tell WebGL that each vertex contains 5 elements, using the parameter <span class="parameter">stride</span>. If such information is provided, WebGL would know how to fetch the position data for second vertex - it just simply skips the next 3 elements.</p>
                            <p><span class="parameter">stride</span> and <span class="parameter">offset</span> should be specified in units of bytes. Since <span class="parameter">stride</span> covers 5 elements, and each element has bytes of Float32Array.BYTES_PER_ELEMENT, we can calculate the total bytes of these 5 elements:</p>
                            <pre>
Float32Array.BYTES_PER_ELEMENT * 5
</pre>
                            <p>And this value is thus specified for <span class="parameter">stride</span>.</p>
                            <p><span class="parameter">normalized</span> tells WebGL whether the data should be converted (normalized) in range [-1, 1]. The coordinate values we use here, such as [0.0, 0.5], are alreay in range [-1, 1], so we needn't the convertion by setting the value of <span class="parameter">normalized</span> with 'false'.</p>
                            <p>Back to the situation that vertices contains only position information:</p>
                            <pre>
var vertices = [
   //only positions, no colors  
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
];</pre>
                            <p>We specify '0' for <span class="parameter">stride</span>, meaning the data are tightly packed in the array. :</p>
                            <pre>
gl.vertexAttribPointer(index, 2, gl.FLOAT, false, 0, 0);
</pre>
                            <p>Now, WebGL has the sufficient information on how to fetch position data from the buffer, and knows well which vertex attribute to transfer the data to.</p>
                        </section>
                        
                    </section>
                </section>
            </section>
            
            <section class="chapter">
                <h1>Pipelines: a Big Picture</h1>
                <p>Now, time to put all these in a big picture. We will follow each key step and draw the according WebGL state step by step.</p>
                <p>1. Program and Shaders</p>
                <pre>
&lt;script id="vshader" type="x-shader/x-vertex"&gt;
    attribute vec4 vPosition;

    void main()
    {
        gl_Position = vPosition;
    }
&lt;/script&gt;

&lt;script id="fshader" type="x-shader/x-fragment"&gt;
    precision mediump float;

    void main()
    {
        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
&lt;/script&gt;

gl.program = prepareProgram("vshader", "fshader");
</pre>
                <p>Diagram:</p>
                <img src="images/svg/pipelines-big-picture-1.svg" alt="pipelines-big-picture-1.svg" />
                <p>We declare an attribute variable <span class="variable-name">vPosition</span> and assign its value to <span class="variable-name">gl_Position</span>. The red arrow means its data will be moved to <span class="variable-name">gl_Position</span> while rendering.</p>
                <p>At this time, nothing points to the <span class="constant">ARRAY_BUFFER</span> and the <span class="variable-name">vPosition</span>'s state is disabled.</p>
                
                <p>2. Client Buffer</p>
                <pre>
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
</pre>
                <p>Diagram:</p>
                <img src="images/svg/pipelines-big-picture-2.svg" alt="pipelines-big-picture-2.svg" />
                <p>We create a <span class="variable-name">buffer</span> object in the memory area managed by the WebGL and bind it to <span class="constant">ARRAY_BUFFER</span> target. Since <span class="variable-name">buffer</span> will store vertice data, it is usually called <em>VBO</em>(Vertex Buffer Object).</p>
                <p>At this time, <span class="variable-name">buffer</span>'s contents are empty.</p>
                
                <p>3. Copy Data to VBO</p>
                <pre>
var vertices = [
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
</pre>
                <p>Diagram:</p>
                <img src="images/svg/pipelines-big-picture-3.svg" alt="pipelines-big-picture-3.svg" />
                <p>We declare a <span class="variable-name">vertices</span> variable in JavaScript client side, and pack the data of it into a Float32Array, and copy the data from <span class="variable-name">vertices</span> to <span class="variable-name">buffer</span>.</p>
                <p>Note that <span class="variable-name">buffer</span> is not appeared as an argument in method <span class="function-name">bufferData</span>. Rather, <span class="function-name">bufferData</span> takes gl.<span class="constant">ARRAY_BUFFER</span> as its first argument, which means WebGL would copy data to the VBO who is bound to gl.<span class="constant">ARRAY_BUFFER</span> target. Since <span class="variable-name">buffer</span> is bound to this target, data would be copied to it.</p>
                <p>The gray arrow here means <span class="function-name">bufferData</span> is consuming the WebGL gl.<span class="constant">ARRAY_BUFFER</span> state. So that we know clearly the bounding to gl.<span class="constant">ARRAY_BUFFER</span> would affect the result of <span class="function-name">bufferData</span>.</p>
                <p>Now, <span class="variable-name">buffer</span> is filled with the data copied from <span class="variable-name">vertices</span>.</p>
                
                <p>4. Enable Veretex Attribute Array</p>
                <pre>
var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);
</pre>
                <p>Diagram:</p>
                <img src="images/svg/pipelines-big-picture-4.svg" alt="pipelines-big-picture-4.svg" />
                <p><span class="variable-name">vPosition</span> is now enabled as an array, satisfying with the prerequisite of <span class="function-name">drawArrays</span>.</p>
                
                <p>5. Rules to fetch data</p>
                <pre>
gl.vertexAttribPointer(index, 2, gl.FLOAT, false, 0, 0);
</pre>
                <p>Diagram:</p>
                <img src="images/svg/pipelines-big-picture-5.svg" alt="pipelines-big-picture-5.svg" />
                <p>The first argument <span class="parameter">index</span> of <span class="function-name">vertexAttribPointer</span> specifies which vertex attribute variable would be copied with the data from WebGL memory. However, it does not mention which VBO it would copy data from. Again, WebGL would look for the source from the VBO who is bound to gl.<span class="constant">ARRAY_BUFFER</span> target and thus lead the data be copied from <span class="variable-name">buffer</span> to <span class="variable-name">vPosition</span>.</p>
                <p>The gray arrow indicates <span class="function-name">vertexAttribPointer</span> is here again consuming the WebGL gl.<span class="constant">ARRAY_BUFFER</span> state.</p>
                <p>Note that although <span class="function-name">vertexAttribPointer</span> implicitly consumes the WebGL gl.<span class="constant">ARRAY_BUFFER</span> state, when the invokation of <span class="function-name">vertexAttribPointer</span> is finished, WebGL has constructed a full bridge connecting with <span class="variable-name">buffer</span> and <span class="variable-name">vPosition</span>. So that from now on, gl.<span class="constant">ARRAY_BUFFER</span> is not subject to be used any more for rendering later. We can bind gl.<span class="constant">ARRAY_BUFFER</span> to null here if we like:</p>
                <pre>gl.bindBuffer(gl.ARRAY_BUFFER, null);</pre>
                
                <p>6. Rendering</p>
                <pre>
gl.drawArrays(gl.TRIANGLES, 0, 3);
</pre>
                <p>Rendering resulted from <span class="function-name">drawArrays</span> or <span class="function-name">drawElements</span> is nothing more than transfering the data from VBOs to vertex attributes, once per vertex, and finally to the frame buffer.</p>
                <p>As you can see, WebGL is a state machine. Drawing in WebGL is as easy as setting the WebGL states correctly, providing the vertex data, and issuing the drawing methods.</p>
            </section>
            
            <section class="chapter">
                <h1>Yellow Triangle</h1>
                <p>Time to turn all above into a runnable WebGL application. </p>
                <pre>
&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Yellow Triangle&lt;/title&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;

        &lt;script id="vshader" type="x-shader/x-vertex"&gt;
            attribute vec4 vPosition;

            void main()
            {
                gl_Position = vPosition;
            }
        &lt;/script&gt;

        &lt;script id="fshader" type="x-shader/x-fragment"&gt;
            precision mediump float;

            void main()
            {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
            }
        &lt;/script&gt;

        &lt;script type="text/javascript"&gt;
            var gl;

            function init() {
                if (!window.WebGLRenderingContext) {
                    alert("Your browser doese not support WebGL!");
                    return;
                }

                var canvas = document.getElementById("webglcanvas");
                gl = canvas.getContext("webgl");

                if (!gl) {
                    alert("Unable to initialize WebGL!");
                }
                
                gl.program = prepareProgram("vshader", "fshader");
                
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                
                var vertices = [
                     0.0,  0.5,
                    -0.5, -0.5,
                     0.5, -0.5
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                
                var index = gl.getAttribLocation(gl.program, "vPosition");
                gl.enableVertexAttribArray(index);
                gl.vertexAttribPointer(index, 2, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                
                render();
            }
            
            function prepareProgram(vshader, fshader) {
                var vertexShader = loadShader(gl, vshader);
                var fragmentShader = loadShader(gl, fshader);

                var program = gl.createProgram();

                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);

                gl.linkProgram(program);

                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                    var error = gl.getProgramInfoLog(program);
                    console.log("Error in program linking: " + error);

                    gl.deleteProgram(program);
                    gl.deleteProgram(fragmentShader);
                    gl.deleteProgram(vertexShader);

                    return null;
                }

                gl.useProgram(program);

                return program;
            }

            function loadShader(ctx, shaderId) {
                var shaderScript = document.getElementById(shaderId);

                if (!shaderScript) {
                    console.log("Error: shader script '" + shaderId + "' not found");
                    return null;
                }

                var shaderType;

                if (shaderScript.type === "x-shader/x-vertex")
                    shaderType = ctx.VERTEX_SHADER;
                else if (shaderScript.type === "x-shader/x-fragment")
                    shaderType = ctx.FRAGMENT_SHADER;
                else {
                    console.log("Error: shader script '" + shaderId + "' of undefined type '" + shaderScript.type + "'");
                    return null;
                }

                var shader = ctx.createShader(shaderType);

                ctx.shaderSource(shader, shaderScript.text);
                ctx.compileShader(shader);

                var compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
                if (!compiled) {
                    var error = ctx.getShaderInfoLog(shader);
                    console.log("Error compiling shader '" + shaderId + "':" + error);
                    ctx.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.drawArrays(gl.TRIANGLES, 0, 3);
            }

            window.addEventListener("DOMContentLoaded", init);
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Yellow Triangle&lt;/h1&gt;
        &lt;canvas id="webglcanvas" width="500" height="500"&gt;Your browser does not support HTML5 Canvas!&lt;/canvas&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
                <p>See <a href="demos/yellow-triangle.html" target="_blank">demo</a>.</p>
            </section>
            
            <section class="chapter">
                <h1>Refactoring</h1>
                <p>Since some codes are always the same in different apps, we can move them into a helper utility named "webgl-utils.js".</p>
                <pre>
webglUtils = {};

webglUtils.initContext = function (canvasId) {
    if (!window.WebGLRenderingContext) {
        alert("Your browser doese not support WebGL!");
        return null;
    }
    
    var canvas = document.getElementById(canvasId);
    if (!canvas) {
        alert("Unable to find '" + canvasId + "' element");
        return null;
    }

    var ctx = canvas.getContext("webgl");

    if (!ctx) {
        alert("Unable to initialize WebGL!");
        return null;
    }
    
    return ctx;
};

webglUtils.prepareProgram = function (ctx, vshader, fshader) {
    var vertexShader = this.loadShader(ctx, vshader);
    var fragmentShader = this.loadShader(ctx, fshader);

    var program = ctx.createProgram();

    ctx.attachShader(program, vertexShader);
    ctx.attachShader(program, fragmentShader);

    ctx.linkProgram(program);

    var linked = ctx.getProgramParameter(program, ctx.LINK_STATUS);
    if (!linked) {
        var error = ctx.getProgramInfoLog(program);
        alert("Error in program linking: " + error);

        ctx.deleteProgram(program);
        ctx.deleteProgram(fragmentShader);
        ctx.deleteProgram(vertexShader);

        return null;
    }

    ctx.useProgram(program);

    return program;
};

webglUtils.loadShader = function (ctx, shaderId) {
    var shaderScript = document.getElementById(shaderId);

    if (!shaderScript) {
        alert("Error: shader script '" + shaderId + "' not found");
        return null;
    }

    var shaderType;

    if (shaderScript.type === "x-shader/x-vertex")
        shaderType = ctx.VERTEX_SHADER;
    else if (shaderScript.type === "x-shader/x-fragment")
        shaderType = ctx.FRAGMENT_SHADER;
    else {
        alert("Error: shader script '" + shaderId + "' of undefined type '" + shaderScript.type + "'");
        return null;
    }

    var shader = ctx.createShader(shaderType);

    ctx.shaderSource(shader, shaderScript.text);
    ctx.compileShader(shader);

    var compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
    if (!compiled) {
        var error = ctx.getShaderInfoLog(shader);
        alert("Error compiling shader '" + shaderId + "':" + error);
        ctx.deleteShader(shader);
        return null;
    }

    return shader;
};                    
</pre>
                <p>With this, the contents of 'yellow-triangle.html' are changed:</p>
                <pre>
&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Yellow Triangle&lt;/title&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        
        &lt;script src="../../../../js/webgl-utils.js"&gt;&lt;/script&gt;

        &lt;script id="vshader" type="x-shader/x-vertex"&gt;
            attribute vec4 vPosition;

            void main()
            {
                gl_Position = vPosition;
            }
        &lt;/script&gt;

        &lt;script id="fshader" type="x-shader/x-fragment"&gt;
            precision mediump float;

            void main()
            {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
            }
        &lt;/script&gt;

        &lt;script type="text/javascript"&gt;
            var gl;

            function init() {
                gl = webglUtils.initContext("webgl-canvas");
                
                gl.program = webglUtils.prepareProgram(gl, "vshader", "fshader");
                
                initVBOs();
                
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                render();
            }
            
            function initVBOs() {
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                
                var vertices = [
                     0.0,  0.5,
                    -0.5, -0.5,
                     0.5, -0.5
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                
                var index = gl.getAttribLocation(gl.program, "vPosition");
                gl.enableVertexAttribArray(index);
                gl.vertexAttribPointer(index, 2, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }
            
            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.drawArrays(gl.TRIANGLES, 0, 3);
            }

            window.addEventListener("DOMContentLoaded", init);
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Yellow Triangle&lt;/h1&gt;
        &lt;canvas id="webgl-canvas" width="500" height="500"&gt;Your browser does not support HTML5 Canvas!&lt;/canvas&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
                <p>The concerns are quite clear now:</p>
                <ol>
                    <li>provide sources for both shaders</li>
                    <li>init the webgl context</li>
                    <li>prepare the program</li>
                    <li>init VBOs</li>
                    <li>render</li>
                </ol>
                <p>The most important part is <span class="function-name">initVBOs</span>. Take some time looking over at the codes of it, thinking about how each statement affect the WebGL's states. This is the WebGL way to program. Once we get customed to it, it'll be rather easy to do WebGL programming.</p>
                <p>See <a href="demos/yellow-triangle-refactored.html" target="_blank">demo</a>.</p>
            </section>

            <section class="reference">
                <h1>References</h1>
                <ul>
                    <li><a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/es_full_spec_2.0.pdf#nameddest=section-2.8" target="_blank">OpenGL ES 2.0 Specification (PDF)</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/" target="_blank">OpenGL ES 2.0 Reference Pages</a></li>
                    <li><a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/" target="_blank">WebGL 1.0 Specification</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glDrawArrays.xml" target="_blank">glDrawArrays</a></li>
                    <li><a href="https://www.w3.org/TR/SVG11/" target="_blank">SVG 1.1 Specification</a></li>
                    <li><a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank">Media Types</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.50.pdf" target="_blank">The OpenGL Shading Lanuage V4.5 (PDF)</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf" target="_blank">The OpenGL ES Shading Lanuage V1.0 (PDF)</a></li>
                </ul>
            </section>
            
            <p>Previous: <a>Introduction</a> | <a>Table of Contents</a> | Next: <a>Drawing</a></p>
            
            <footer><p class="copyright">All rights reserved.</p></footer>
        </article>
    </body>
</html>

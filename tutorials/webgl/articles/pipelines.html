<!DOCTYPE html>

<html>
    <head>
        <title>WebGL Pipelines</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel="shortcut icon" href="../../../images/png/WebGL-Logo.png" type="image/png" />
        
        <link rel="stylesheet" href="../../../css/style.css">
        <link rel="stylesheet" href="../../../css/document.css">
        
        <style type="text/css">
            img, object {
                border: 1px solid #666;
                box-shadow: 3px 3px 3px #666;
                display: block;
                margin: 0 auto;
            }
        </style>
        
        <script src="../../../js/htmlDocUtils.js"></script>
    </head>
    <body>
        <article>
            <header>
                <h1>WebGL Pipelines</h1>
                <p class='authorinfo'>Sarkuya, <time>2019-05-19</time></p>
            </header>
            
            <section class="chapter">
                <h1>How WebGL Draw</h1>
                <p>In order to draw something in the canvas, we need to issue certain drawing methods. WebGL has only 3 methods dealing with drawing:</p>
                <ul>
                    <li>clear</li>
                    <li>drawArrays</li>
                    <li>drawElements</li>
                </ul>
                <p>We have encountered the <span class="function-name">clear</span> method before, and in the following section we'll talk about <span class="function-name">drawElements</span>. In this section, we discuss <span class="function-name">drawArrays</span> first.</p>
                <p>Suppose we shall draw a triangle. First, we need to provide the vertices. Second, issue the drawing method. The code is below:</p>
                <pre class="highlight">
var vertices = [
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
];

gl.drawArrays(gl.TRIANGLES, 0, 3);  // intent: use the array data in vertices to draw a triangle
</pre>
                <p>The synopsis of the <span class="function-name">drawArrays</span> is as followed.</p>
                <pre>void drawArrays(GLenum mode, GLint first, GLsizei count)</pre>
                <p><span class="parameter">mode</span> specifies the kind of primitives. Accepted constants are gl.<span class="constant">POINTS</span>, gl.<span class="constant">LINE_STRIP</span>, gl.<span class="constant">LINE_LOOP</span>, gl.<span class="constant">LINES</span>, gl.<span class="constant">TRIANGLE_STRIP</span>, gl.<span class="constant">LINE_FAN</span>, and  gl.<span class="constant">TRIANGLES</span>, where <span class="variable-name">gl</span> is an instance of the <span class="class-name">WebGLRenderingContext</span>.</p>
                <p><span class="parameter">first</span> specifies the starting index of the array.</p>
                <p><span class="parameter">count</span> specifies the number of vertices to be rendered.</p>
                <p>There are 3 points in vertices array data. Each point has a pair of array elements. From the first point, which starting index is 0, fetches altogether 3 vertices to draw triangles. In this situation, 3 vertices would compose only 1 triangle.</p>
                <p>You can see from the code that there are no connections between the <span class="function-name">drawArrays</span> and the vertices. So how WebGL know where to get the array data from?</p>
                <p>WebGL will rather get the array data from a buffer, than directly from the vertices we are providing. The buffer is resident in GPU, and the speed of data transmission from it is much faster than from the vertices, which is resident in JavaScript client side.</p>
                <p>So, we need to do the following jobs:</p>
                <ol>
                    <li>create a buffer (in GPU)</li>
                    <li>copy the data from the vertices to the buffer</li>
                    <li>tell WebGL to fetch array data from the buffer</li>
                </ol>
                <pre class="highlight">
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var vertices = [
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
];

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
</pre>
                <p>Notice the first argument of the <span class="function-name">bufferData</span> is gl.<span class="constant">ARRAY_BUFFER</span>. 
This is the specific buffer binding target where the WebGL would fetch the array data. 
So after we created a buffer, we bind the buffer to the target gl.ARRAY_BUFFER. 
<span class="function-name">bufferData</span> connects the buffer with gl.ARRAY_BUFFER via putting the latter as its first argument.
So the array data from the vertices would be copied to the GPU's buffer.</p>
                <p>Then when we issue the drawing method, WebGL konws it should get the vertex data from the buffer to render the image.</p>

                <object type="image/svg+xml" data="images/svg/pipelines.svg"></object>
                
                <p>We need to deal with the following objects:</p>
                <ul>
                    <li>WebGLRenderingContext</li>
                    <li>shaders</li>
                    <li>program</li>
                    <li>buffer</li>
                    <li>vertices</li>
                    <li>drawing functions</li>
                </ul>
            </section>
            
            <section class="chapter">
                <h1>Coming the Shaders</h1>
                <p>When we issue the drawing method, again, WebGL would never fetch the data directly from the buffer. 
                    Rather, it would ask the <em>shaders</em> to provide the corresponding informations. Shaders are executed on the <em>GPU</em>, so their speed are extremely fast.</p>
                <p>There are several shaders in WebGL. Among of them, vertex shader and fragment shader are two shaders which are mandatory in each WebGL application, while other shaders are optional.</p>
                <p>Put in simplified, vertex shader deals with the positions of vertices, while fragment deals with the colors of vertices.</p>
                <p>The following driagram illustrates how WebGL fetch the data from the vertex shader and fragment shader to render the final image.</p>
                <object type="image/svg+xml" data="images/svg/shaders.svg"></object>
                <p>After we issued the drawing method:</p>
                <pre class="highlight">
gl.drawArrays(gl.TRIANGLES, 0, 3);
</pre>
                <p>We tells WebGL to fetch 3 vertex components, starting from index 0, to construct a triangle. 
Each component contains 2 array elments, relating to the X axis and Y axis coordinate.</p>
                <p>In deciding the first vertex, the first two array elements, [0.0, 0.5] will be passed to the vertex shader, and be assigned to the special variable <span class="variable-name">gl_Position</span>. To achive this, we can code like this using <em>GLSL</em>(OpenGL Shading Language):</p>
                <pre class="highlight">
attribute vec4 vPosition;

void main()
{
    gl_Position = vPosition;
}
</pre>
                <p>Here, "attribute" is a storage qualifier. The attribute <span class="variable-name">vPosition</span> is a variable in vertex shader that can accept the data from the buffers on a per-vertex basis. The attribute qualifier exists in vertex shader only, not other shaders. We can regard it as a tunnel connecting with the buffers and shaders. 
WebGL would transfer data [0.0, 0.5] from the buffer to <span class="variable-name">vPosition</span>. Then, in the <span class="function-name">main</span> function, its value is assigned to <span class="variable-name">gl_Position</span>.</p>
                <p>Putting vertex data in <span class="variable-name">vPosition</span> is the final step in this stage to decide each vertex's position from the view of a programmer. Many other left dirty works would be handled by WebGL in pipelines from now on, but not for programmer.</p>
                <p>Then, this data would be passed on to the the Fragment Shader in WebGL's rendering pipelines. As the first WebGL program based on shaders, we can simplify the issue by assign all vertices with just a yellow color. Code like this:</p>
                <pre class="highlight">
precision mediump float;

void main()
{
    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
}
</pre>
                <p>We use 'float' to describe the precision of the data. 
Just like <span class="variable-name">gl_Position</span>, <span class="variable-name">gl_FragColor</span> is a special variable that deal with vertex color. 
We hard-coded the yellow color value and assigned it to <span class="variable-name">gl_FragColor</span>, which means no matter how many vertices we have, they all have a same color.</p>
                <p>Now the Fragment Shader has the information of a vertex's position and its color, which is enough to plot a pixel in screen. So the data is moved on to the frame buffer to be rendered. This first vertex is thus rendered on screen. And this finishes the first cycle of invocation of <span class="function-name">glDrawArrays(gl.TRIANGLES, 0, 3)</span>.</p>
                <p>The last parameter in <span class="function-name">glDrawArrays(gl.TRIANGLES, 0, 3)</span> tells WebGL that there would be 2 vertices left. Again, WebGL asks the Vertex Shader to provide the information of the second vertex. Then, the 2th and the 3rd array elements, [-0.5, -0.5] will passed on to <span class="variable-name">gl_Position</span> in Vertex Shader. The remaiming procedures are the same with above - data would be moved on to the Fragment Shader and then to the Frame Buffer to plot the second vertex on screen.</p>
                <p>As for the 3rd cycle, [0.5, -0.5] would be extracted from the buffer to the shaders and then the Frame Buffer. Thus, a t yellow triangle is rendered.</p>
                <p>You can see that Shading Language is powerful - there is only 1 <span class="variable-name">gl_Position</span> for all vertice's positions and 1 <span class="variable-name">gl_FragColor</span> all for vertices' colors. We write in less codes and WebGL do much more works to get all vertice's information. It would be true that Shading Language shown above is much easier than any other programming language, such as C, Java, even JavaScript. Despite of this, Shading Language is nevertheless a programming language, and just like any other one, it needs to be compiled and linked before being used.</p>
            </section>
            
            <section class="chapter">
                <h1>Compiling and Linking of Shaders</h1>
                <p>We now know what shaders are, how they function, and how to write codes for shaders, then one issue is left here: get the shaders compiled and linked. The following dragram shows the procedures how to do this.</p>
                <img src="images/svg/compile-shaders.svg" alt="Preparing Program" />
                <p>Although it might look rather complicated, the big picture is simple: create 2 shaders, attatch them to a program, link the program, and use the program.</p>
                
                <section>
                    <h1>Creating Shaders</h1>
                    <p>The procedures of creating the vertex shader and fragment shader are the same, so we could put the codes of creating shaders in a function.</p>
                    <p>Before we do it, we should decide where to put the shader sources first. </p>
                    <p>Shader's sources are plain texts. So we can write them in a text file and load the text file using the AJAX. However, for a simple WebGL application, there's a good place for holding the shaders' sources - <span class="htmltag">script</span> element in a HTML file.</p>
                    <p>For JavaScript to be executed by the web browser, we usually specify its <span class="attribute-name">type</span> attribute.</p>
                    <pre class="highlight">
&lt;script type="text/javascript"&gt;
    ...
&lt;/script&gt;
</pre>
                    <p><span class="attribute-name">type</span> specifies the MIME type. It contains the information of media type and its sub-type. For the code above, the media type is text, and its sub-type is javascript.</p>
                    <p>If we don't specify the <span class="attribute-name">type</span>, it is assumed to be JavaScript by default. And if we specify another type rather than 'javascript' for the <span class="htmltag">script</span>, this script would not be treated as JavaScript and would not be executed by browsers.</p>
                    <p>Although it's not the standard, Khronos takes 'x-shader/x-vertex' for the vertex shader and 'x-shader/x-fragment' for the fragment shader.</p>
                    <p>So, let's add 2 scripts specific to WebGL under the <span class="htmltag">head</span> of <span class="htmltag">html</span>.</p>
                    <pre class="highlight">
&lt;html&gt;
    &lt;head&gt;
        ...

        &lt;script id="vshader" type="x-shader/x-vertex"&gt;
            attribute vec4 vPosition;

            void main()
            {
                gl_Position = vPosition;
            }
        &lt;/script&gt;

        &lt;script id="fshader" type="x-shader/x-fragment"&gt;
            precision mediump float;

            void main()
            {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
            }
        &lt;/script&gt;
        ...
    &lt;/head&gt;

    ...
&lt;/html&gt;
</pre>
                    <p>Then, we use a function to load both of the shaders.</p>
                    <pre class="highlight">
function loadShader(ctx, shaderId)
{
    var shaderScript = document.getElementById(shaderId);
    
    if (!shaderScript) {
        console.log("Error: shader script '" + shaderId + "' not found");
        return null;
    }

    var shaderType;
    
    if (shaderScript.type === "x-shader/x-vertex")
        shaderType = ctx.VERTEX_SHADER;
    else if (shaderScript.type === "x-shader/x-fragment")
        shaderType = ctx.FRAGMENT_SHADER;
    else {
        console.log("Error: shader script '" + shaderId + "' of undefined type '" + shaderScript.type + "'");
        return null;
    }

    var shader = ctx.createShader(shaderType);

    ctx.shaderSource(shader, shaderScript.text);
    ctx.compileShader(shader);

    var compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
    if (!compiled) {
        var error = ctx.getShaderInfoLog(shader);
        console.log("Error compiling shader '" + shaderId + "':" + error);
        ctx.deleteShader(shader);
        return null;
    }

    return shader;
}
</pre>
                </section>
                
                <section>
                    <h1>Getting the Program Ready</h1>
                    <p>We put the codes of preparing a program into a function and invoke it.</p>
                    <pre class="highlight">
function prepareProgram(vshader, fshader) {
    var vertexShader = loadShader(gl, vshader);
    var fragmentShader = loadShader(gl, fshader);

    var program = gl.createProgram();

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);

    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
        var error = gl.getProgramInfoLog(program);
        console.log("Error in program linking: " + error);

        gl.deleteProgram(program);
        gl.deleteProgram(fragmentShader);
        gl.deleteProgram(vertexShader);

        return null;
    }

    gl.useProgram(program);

    return program;
}

gl.program = prepareProgram("vshader", "fshader");
</pre>
                </section>
            </section>
            
            <section class="chapter">
                <h1>Telling WebGL How to Fetch Data</h1>
                <p></p>
                
                <section>
                    <h1>What are Shader's Attributes</h1>
                    <p>Buffers are memory areas managed by WebGL system, which are located in the ordinary memory. If we can transfer the data in buffers to GPU's memories, and process graphics-relating tasks such as lighting computing in GPU to leverage the full capabilities of GPU, that would be a better solution in performance. WebGL adopts such a solution in its rendering pipelines.</p>
                    <p>In shading language, attribute variables are such ones that can accept and store the data from outside the GPU. Each attribute variable points to a small block of memory spaces allocated in GPU. The diagram below illustrates this.</p>
                    <img src="images/svg/shader-attribute-1.svg" alt="Shader Attributes" />
                    <p>We can see that, each attribute variable has an index, 4 components, a name, and a flag that indicates whether it is enabled as an array.</p>
                    <p>The numbers of vertex attributes are limited in each implementation. We can query the max vertex attributes numbers by passing the gl.<span class="constant">MAX_VERTEX_ATTRIBS</span> constant to the <span class="function-name">getParameter</span> method.</p>
                    <pre class="highlight">
var vertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);    // 16 in Safari V11.1
</pre>
                    <p>In all shaders, only vertex shader has attribute variables.</p>
                    
                </section>
                
                <section>
                    <h1>Index and Name</h1>
                    <p></p>
                    <p>We coded for the vertex shader as followed before:</p>
                    <pre class="highlight">
&lt;script id="vshader" type="x-shader/x-vertex"&gt;
    attribute vec4 vPosition;

    void main()
    {
        gl_Position = vPosition;
    }
&lt;/script&gt;
</pre>
                    <p>Here, the keyword "<em>attribute</em>" is called <em>storage qualifier</em>. Its type is vec4, and its name is "vPosition". With this declaration, the WebGL' states turns into:</p>
                    <img src="images/svg/shader-attribute-2.svg" alt="Shader Attributes" />
                    <p>It means that the first attribute space, whose index is 0, will be reserved for 'vPosition' variable.</p>
                    <p>From the view of the code, we know there is a attribute named 'vPosition', while we don't know the exact index of it. By invoking the gl.getAttribLocation method, we can get its index.</p>
                    <pre class="highlight">
var index = gl.getAttribLocation(gl.program, "vPosition");
</pre>
                </section>
                
                <section>
                    <h1>Four Componets in an Attribute</h1>
                    <p>Normally, we declare attributes to store the data of position, color, normal, texture cocordinte and matrix. All of these data have max 4 compoments. To reflect with this, each attribute has 4 components. For position, color, normal and texture coordinate, each component has a floating-point value. As for the matrix, we have kinds of mat4, mat3, and mat2. A mat4 would use up 4 attribute variable location, a mat3 would use up 3 attrbute variable location, and a mat2 would use up 2 attribute variable location.</p>
                </section>
                
                <section>
                    <h1>How to Set an Attribute's Value</h1>
                    <p>There are 2 ways to set an attribute's value. </p>
                    <p>The first way is to set directly by invoking the gl's method <span class="function-name">vertexAttrib</span>, which we'll deal with later.</p>
                    <p>The second way is driven by gl's method <span class="function-name">drawArrays</span>, or <span class="function-name">drawElments</span>. In this way, the attribute's value are not set directly, but rather, they are set by accepting the data transfered from buffers. However, to make this happened, we would have to do 3 jobs first:</p>
                    <ol>
                        <li>make an attribute active</li>
                        <li>enable the attribute as an array</li>
                        <li>tell WebGL the rules to fetch the data</li>
                    </ol>
                    
                    <section>
                        <h1>Make an Attribute Active</h1>
                        <p>An attribute variable is considered active if it is determined during the link operation that it may be accessed during program execution.</p>
                        <pre class="highlight">
attribute vec4 vPosition;
attribute vec4 vTest;

void main()
{
    gl_Position = vPosition;
}
</pre>
                        <p>We declared 2 attributes. Only <span class="variable-name">vPosition</span> is being used to assign its value to <span class="variable-name">gl_Position</span>, which can be determined during the link operation. In short, it was consumed. So, only <span class="variable-name">vPosition</span> is active and <span class="variable-name">vTest</span> is not.</p>
                    </section>
                    
                    <section>
                        <h1>Enable the Attribute as an Array</h1>
                        <p>Since <span class="variable-name">vPosition</span> is about to be accessed to assign values to <span class="variable-name">gl_Position</span>, it should have its value set before that. As we said before that being an attribute, <span class="variable-name">vPosition</span> has 4 floating components. We should turn these 4 components into an array if it is about to accept data from a buffer which is in a form of array for the efficiency. And that's why <span class="function-name">glDrawArrays</span> is so named: it would fetch data from arrays to render images.</p>
                        <p>By default, all generic vertex attribute arrays are disabled. So, we should enable the generic vertex attribute array like this:</p>
                        <pre class="highlight">
var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);
</pre>
                        <img src="images/svg/shader-attribute-3.svg" alt="Shader Attributes" />
                        
                        <p><span class="function-name">enableVertexAttribArray</span> method enables the vertex attribute at index as an array. Only when the attribute is enabled, would the values in the generic vertex attribute array be accesed when rendering.</p>
                        <p>If we try to enable an attribute which is not active , error would occur.</p>
                    </section>
                    
                    <section>
                        <h1>Tell WebGL the Rules to Fetch the Data</h1>
                        <p>At this time, we have finished the following relating statements:</p>
                        <pre class="highlight">
// buffer created and bound before
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);
</pre>
                        <p>The buffer bound to gl.ARRARY_BUFFER target is the current bounding buffer that would transfer its data to vertex shader. However, since we can enable more than one attribute as array in a certain time, we have no information which attribute would accept the data from the buffer.</p>
                        <p>Second, the data from the buffer might contain more than merely the vertices's position data, like this:</p>
                        <pre class="highlight">
var vertices = [
   //position      color          
     0.0,  0.5,    1.0, 0.0, 0.0,
    -0.5, -0.5,    0.0, 1.0, 0.0,
     0.5, -0.5,    0.0, 0.0, 1.0
];
</pre>
                        <p>Since vertex shader cares about only the vertice's position, we should tell WebGL how to fetch the vertice's position out of such mixed array buffer.</p>
                        <p><span class="function-name">vertexAttribPointer</span> serves for this purpose as well, specified in its arguments.</p>
                        <p>The synopsis of the <span class="function-name">vertexAttribPointer</span>:</p>
                        <pre>void vertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normailized, GLsizei stride, GLintptr offset)</pre>
                        <p>Let's take the mixed vertices in example to illustrate the functionality of <span class="function-name">vertexAttribPointer</span> first, and then a vertex of pure positions, since the first is a better demo than the latter.</p>
                        <p>Put the previous relavant codes here again:</p>
                                                <pre class="highlight">
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

var vertices = [
   //position      color          
     0.0,  0.5,    1.0, 0.0, 0.0,
    -0.5, -0.5,    0.0, 1.0, 0.0,
     0.5, -0.5,    0.0, 0.0, 1.0
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

var index = gl.getAttribLocation(gl.program, "vPosition");
gl.enableVertexAttribArray(index);

gl.vertexAttribPointer(index, 2, gl.FLOAT, false, 0, 0);
</pre>
                        
                        
                        <p><span class="function-name">vertexAttribPointer</span> is a bridge that connects with 2 ends. As the codes above shows, one end is the buffer we created and bound to the gl.<span class="constant">ARRAY_BUFFER</span> before, and the other end is <span class="variable-name">vPosition</span>. So, by using <span class="function-name">vertexAttribPointer</span>, we tell WebGL where to fetch the data, and where to transfer.</p>
                        
                        <p>We can invoke <span class="function-name">getVertexAttrib</span> to query informations.</p>
                    </section>
                </section>
                
                <section>
                    <h1>bbb</h1>
                    <p>Attributes has the following feafures:</p>
                    <ul>
                        <li>each attribute ponints to a buffer</li>
                        <li>to let attribute has a value, should via enable it as an array driven by glDrawArray, or vertexAttrib method</li>
                    </ul>
                    <img src="images/svg/shader-attribute-4.svg" alt="Shader Attribute Array" />
                </section>
            </section>

            <section class="reference">
                <h1>References</h1>
                <ul>
                    <li><a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/es_full_spec_2.0.pdf#nameddest=section-2.8" target="_blank">OpenGL ES 2.0 Specification (PDF)</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/" target="_blank">OpenGL ES 2.0 Reference Pages</a></li>
                    <li><a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/" target="_blank">WebGL 1.0 Specification</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glDrawArrays.xml" target="_blank">glDrawArrays</a></li>
                    <li><a href="https://www.w3.org/TR/SVG11/" target="_blank">SVG 1.1 Specification</a></li>
                    <li><a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank">Media Types</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.50.pdf" target="_blank">The OpenGL Shading Lanuage V4.5 (PDF)</a></li>
                    <li><a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf" target="_blank">The OpenGL ES Shading Lanuage V1.0 (PDF)</a></li>
                </ul>
            </section>
            
            <p>Previous: <a>Introduction</a> | <a>Table of Contents</a> | Next: <a>Drawing</a></p>
            
            <footer><p class="copyright">All rights reserved.</p></footer>
        </article>
    </body>
</html>
